# Bug B11: Missing Resource Cleanup for Subprocesses

## Severity
**Low Priority** - Theoretical Issue

## Location
Throughout `src/worktreeflow/wtf.py` - all subprocess calls with `shell=True`

## Description
Subprocess calls using `shell=True` could potentially leave zombie processes in error cases, though Python's garbage collection usually handles this.

## Current Pattern
```python
# In BashCommandLogger.execute() - Line 174
result = subprocess.run(
    bash_cmd,
    shell=True,
    check=check,
    capture_output=capture_output,
    text=True
)
```

This pattern is used throughout the codebase for executing Git commands.

## Problem
When using `shell=True`, subprocess.run() creates:
1. A shell process
2. The actual command process

If the Python process is interrupted (SIGTERM, SIGKILL) or crashes:
- The subprocess may not be properly cleaned up
- Could leave zombie processes
- Resources may not be released

## Why This Is Usually Not a Problem
Python's `subprocess.run()` with proper context management (which it uses internally) typically handles cleanup well:
- Normal termination: Processes are reaped automatically
- Exception handling: Context managers ensure cleanup
- Process references: CPython's garbage collector cleans up

## When This Could Be a Problem
1. **Hard crashes**: SIGKILL, segfault, out of memory
2. **Long-running commands**: If interrupted mid-execution
3. **Multiple concurrent processes**: Resource exhaustion
4. **Signal handling**: Custom signal handlers might interfere

## Real-World Impact
**Very low** - Modern Python (3.3+) has good subprocess cleanup:
- `subprocess.run()` waits for process completion
- Context managers handle exceptions
- OS cleans up zombies on parent exit

## Proposed Improvements

### Option 1: Add explicit cleanup (minimal benefit)
```python
import signal
import atexit

class BashCommandLogger:
    def __init__(self, debug: bool = False, dry_run: bool = False):
        self.debug = debug
        self.dry_run = dry_run
        self.commands: List[CommandEntry] = []
        self.active_processes = []

        # Register cleanup handler
        atexit.register(self._cleanup_processes)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _cleanup_processes(self):
        """Clean up any active subprocesses."""
        for proc in self.active_processes:
            try:
                proc.terminate()
                proc.wait(timeout=5)
            except:
                proc.kill()

    def _signal_handler(self, signum, frame):
        """Handle signals by cleaning up."""
        self._cleanup_processes()
        sys.exit(1)
```

### Option 2: Use Popen with context manager
```python
def execute(self, bash_cmd: str, description: Optional[str] = None,
            check: bool = True, capture_output: bool = True):
    """Execute with explicit process management."""
    self.log(bash_cmd, description)

    if self.dry_run:
        return subprocess.CompletedProcess(args=bash_cmd, returncode=0, stdout="", stderr="")

    # Use Popen for more control
    import subprocess
    import shlex

    try:
        proc = subprocess.Popen(
            bash_cmd,
            shell=True,
            stdout=subprocess.PIPE if capture_output else None,
            stderr=subprocess.PIPE if capture_output else None,
            text=True
        )

        stdout, stderr = proc.communicate()

        if check and proc.returncode != 0:
            raise subprocess.CalledProcessError(
                proc.returncode, bash_cmd, stdout, stderr
            )

        return subprocess.CompletedProcess(
            bash_cmd, proc.returncode, stdout, stderr
        )
    finally:
        # Ensure process is cleaned up
        if proc.poll() is None:
            proc.kill()
            proc.wait()
```

### Option 3: Avoid shell=True (best practice)
```python
# Instead of:
subprocess.run("git status", shell=True)

# Use:
subprocess.run(["git", "status"], shell=False)
```

This eliminates the extra shell process entirely and improves security.

## Recommendation
1. **Low priority**: Current code is likely fine for typical usage
2. **Best practice**: Gradually migrate away from `shell=True` (also helps with Bug B02 - shell injection)
3. **Don't over-engineer**: Adding complex cleanup for a theoretical issue isn't worthwhile

## Better Investment
Instead of adding cleanup code, focus on:
1. **Eliminating shell=True** (addresses multiple bugs: B02, B05, B11)
2. **Using argument lists** instead of string commands
3. **Leveraging GitPython** more (it handles subprocess management internally)

## Related Issues
- **Bug B02**: Shell injection (shell=True is the root cause)
- **Bug B05**: Path injection (shell=True enables this)

Fixing those bugs by eliminating shell=True would also resolve this theoretical cleanup issue.

## Testing
To test if zombie processes are created:

```bash
# Run a long operation
wtf sync-main &
PID=$!

# Check for child processes
ps --ppid $PID

# Kill parent
kill -9 $PID

# Check for zombies
ps aux | grep defunct
```

In practice, you won't find zombies because subprocess.run() handles this correctly.

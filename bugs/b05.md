# Bug B05: Path Injection in Shell Commands

## Severity
**High Priority** - Potential Security Issue

## Location
`src/worktreeflow/wtf.py:952-956`

## Description
The worktree path is directly interpolated into a shell command with `grep`, which could fail or behave unexpectedly if the path contains special regex or shell metacharacters.

## Current Code
```python
# Check if worktree already exists
if worktree_path.exists():
    # Check if it's a valid worktree
    try:
        wt_check = self.logger.execute(
            f'git worktree list --porcelain | grep "^worktree.*{worktree_path}"',
            "Check if path is a worktree",
            check=False
        )
        if wt_check.returncode == 0:
            console.print(f"[green]✓ Worktree already exists at: {worktree_path}[/green]")
            # ...
```

## Problem
The `worktree_path` is directly interpolated into a grep regex pattern without escaping. This can cause issues with:

1. **Regex metacharacters in path**: `.`, `*`, `[`, `]`, `(`, `)`, `+`, `?`, `{`, `}`, `|`, `^`, `$`
2. **Shell metacharacters**: `;`, `&`, `|`, `>`, `<`, `$`, `` ` ``, `\n`

### Example problematic paths:
```python
# Path with dots (common in git worktrees)
../wt/repo.name/feature  # Dots are regex wildcards

# Path with brackets
../wt/repo[dev]/feature   # Brackets are character classes in regex

# Path with spaces (already has quotes, but still)
../wt/my repo/feature     # Could break in some contexts
```

## Impact
- **Low security risk**: Limited exploitation potential since paths are typically controlled by the user
- **Medium reliability risk**: Valid paths with special characters could fail the check incorrectly
- **Confusion**: Worktrees might not be recognized if paths contain regex metacharacters

## Proposed Fix

### Option 1: Use GitPython native worktree listing
```python
if worktree_path.exists():
    # Check if it's a valid worktree using GitPython
    try:
        # Get list of worktrees
        result = subprocess.run(
            ['git', 'worktree', 'list', '--porcelain'],
            capture_output=True,
            text=True,
            check=True
        )

        # Parse worktree list
        worktrees = []
        for line in result.stdout.split('\n'):
            if line.startswith('worktree '):
                worktrees.append(Path(line[9:]))

        # Check if our path is in the list
        if worktree_path.resolve() in [wt.resolve() for wt in worktrees]:
            console.print(f"[green]✓ Worktree already exists at: {worktree_path}[/green]")
            # ...
```

### Option 2: Escape the path for grep
```python
import re

if worktree_path.exists():
    # Escape regex metacharacters
    escaped_path = re.escape(str(worktree_path))

    try:
        wt_check = self.logger.execute(
            f'git worktree list --porcelain | grep "^worktree {escaped_path}$"',
            "Check if path is a worktree",
            check=False
        )
```

### Option 3: Use grep -F (literal string match)
```python
if worktree_path.exists():
    try:
        # -F treats pattern as literal string, not regex
        wt_check = self.logger.execute(
            f'git worktree list --porcelain | grep -F "worktree {worktree_path}"',
            "Check if path is a worktree",
            check=False
        )
```

## Recommendation
**Option 1** is preferred as it eliminates shell command construction entirely and uses native Git operations. This is more reliable and secure.

## Additional Context
This pattern may exist in other places in the code where paths are used in shell commands. A full audit is recommended:
- Line 1028: `git -C "{git_dir}" push...`
- Line 1090: `git -C "{git_dir}" fetch...`
- Multiple other instances of path interpolation

All should be verified to ensure proper quoting and escaping.

# Bug B07: Overly Broad Exception Handling

## Severity
**Medium Priority**

## Location
Multiple locations in `src/worktreeflow/wtf.py`:
- Line 696
- Line 771
- Line 868
- Line 900
- Line 962

## Description
Multiple functions use bare `except Exception:` clauses that silently swallow all errors with `pass`. This can hide real bugs and make debugging difficult.

## Current Code Examples

### Location 1: sync_main() - Line 696
```python
# Show what's new
self.logger.log(f"git log --oneline {base}..upstream/{base}", "Show new commits")
if not self.dry_run:
    try:
        new_commits = list(self.repo.iter_commits(f"{base}..upstream/{base}"))
        if new_commits:
            console.print(f"\nNew commits from upstream/{base}:")
            for commit in new_commits[:10]:
                console.print(f"  {commit.hexsha[:7]} {commit.summary}")
            if len(new_commits) > 10:
                console.print(f"  ... and {len(new_commits) - 10} more")
        else:
            console.print("[green]Already up-to-date[/green]")
            return
    except Exception:  # <-- Too broad, silently ignores all errors
        pass
```

### Location 2: sync_main_force() - Line 771
```python
try:
    lost_commits = list(self.repo.iter_commits(f"upstream/{base}..{base}"))
    if lost_commits:
        console.print(f"\nCurrent {base} commits that will be LOST:")
        for commit in lost_commits[:10]:
            console.print(f"  {commit.hexsha[:7]} {commit.summary}")
    else:
        console.print("  (none)")
except Exception:  # <-- Too broad
    pass
```

### Location 3: zero_ffsync() - Line 868
```python
try:
    unpushed = list(self.repo.iter_commits(f"origin/{base}..{base}"))
    if unpushed:
        console.print(f"[red]ERROR: Your local {base} has {len(unpushed)} unpushed commit(s)[/red]")
        # ... error message ...
        sys.exit(1)
except Exception:  # <-- Too broad
    pass
```

### Location 4: zero_ffsync() - Line 900
```python
try:
    self.repo.remote("origin").push(f"upstream/{base}:{base}")
    console.print(f"[green]✓ Successfully fast-forwarded origin/{base} to upstream/{base}[/green]")
except GitCommandError as e:  # <-- This one is actually specific (good)
    console.print("[red]ERROR: Push failed. This might happen if:[/red]")
    # ...
```

### Location 5: wt_new() - Line 962
```python
try:
    wt_check = self.logger.execute(
        f'git worktree list --porcelain | grep "^worktree.*{worktree_path}"',
        "Check if path is a worktree",
        check=False
    )
    if wt_check.returncode == 0:
        console.print(f"[green]✓ Worktree already exists at: {worktree_path}[/green]")
        # ...
        return
except Exception:  # <-- Too broad
    pass
```

## Problem
Catching all exceptions and silently ignoring them can:

1. **Hide bugs**: A typo in a branch name would be silently swallowed
2. **Mask GitPython bugs**: Library errors disappear without trace
3. **Make debugging hard**: No indication anything went wrong
4. **Hide configuration errors**: Invalid Git config would pass unnoticed
5. **Suppress unexpected errors**: Memory errors, keyboard interrupts, etc.

### What could be hidden:
- `GitCommandError`: Invalid branch names, missing remotes
- `AttributeError`: GitPython API changes
- `ValueError`: Invalid commit ranges
- `KeyError`: Missing configuration
- Even `KeyboardInterrupt` (though Python 3 fixed this for `except Exception:`)

## Impact
- Makes debugging production issues very difficult
- Users don't get feedback about partial failures
- Silent failures lead to incorrect assumptions about repository state

## Proposed Fix

### Catch specific exceptions
```python
# Option 1: Catch only expected exceptions
try:
    new_commits = list(self.repo.iter_commits(f"{base}..upstream/{base}"))
    if new_commits:
        console.print(f"\nNew commits from upstream/{base}:")
        for commit in new_commits[:10]:
            console.print(f"  {commit.hexsha[:7]} {commit.summary}")
except GitCommandError as e:
    # This is expected if branch doesn't exist or is invalid
    if self.debug:
        console.print(f"[dim]Could not get new commits: {e}[/dim]")
except Exception as e:
    # Unexpected error - log it
    console.print(f"[yellow]Warning: Error getting commit list: {e}[/yellow]")
    if self.debug:
        import traceback
        traceback.print_exc()
```

### Or at minimum, log the error
```python
try:
    new_commits = list(self.repo.iter_commits(f"{base}..upstream/{base}"))
    # ...
except Exception as e:
    # At least log it in debug mode
    if self.debug:
        console.print(f"[yellow]Warning: Could not get new commits: {e}[/yellow]")
    pass
```

## Recommendation
1. Replace all bare `except Exception: pass` with specific exception handling
2. Add logging even for "expected" failures when in debug mode
3. Consider whether each exception should truly be silenced or should inform the user

## Best Practice
```python
try:
    # Risky operation
    result = do_something()
except SpecificExpectedError as e:
    # Handle expected error
    handle_it()
except Exception as e:
    # Log unexpected errors
    logger.warning(f"Unexpected error: {e}")
    if debug:
        raise  # Re-raise in debug mode
```
